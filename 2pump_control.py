from connect import *
from datetime import datetime
from pathlib import Path
import os 
import time
import winsound as wn
import numpy as np
import pyautogui
from datetime import date
from scipy import stats
from scipy import optimize
import random
import pickle
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar


def pump_tester(baudrate = 38400): 
    """    
    Summary:
        uses connect.py from pump manufacturer website to check for open serial ports
        and then generate and return a list of pumps and ports
        
        need to define pumps with numbers 1, 2: pump 1 has the chemical of interest, 
        pump 2 contains the dilution agent
        
        DOES NOT WORK ON WINDOWS IF BLUETOOTH TURNED ON
        (gets stuck on bluetooth COM ports)
    Optional Parameters:
        baudrate (int): baudrate used for communication with Chemyx Fusion Pumps    
    """
    pump_dic = {}
    ports = getOpenPorts()
    print("available COM ports are:", ports)
    for i in ports:
        pump = Pump(i, baudrate)
        pump.run()
        time.sleep(1)
        pump.stop()
        print("this was port:", i)
        connected_input = input("Is it connected to a pump? (enter for yes, any button for no):")
        if connected_input == "":
            print("it is pump number:")
            pump_number = input()
            pump_dic.update({str(pump_number):str(i)})
    return pump_dic




class Pump(object):
    '''
    Description:
        class used to control pumps
        to make multiple commands to pumps go faster, it keeps the connection open untill told otherwise with self.end() method
        also relies on the connect.py import, like everything in this project

    Parameters:
        port (str): COM port to which pump is connected e.g. "COM7"
    
    '''
    def __init__(self, port, communication_rate = 38400):
        self.port = port
        self.baudrate = communication_rate
        self.con = Connection(self.port, self.baudrate)
        self.con.openConnection()
    
    def run(self):
        self.con.startPump()

    def pause(self):
        self.con.pausePump()

    def stop(self):
        self.con.stopPump()
    
    def units(self, units):
        self.con.setUnits(units) 

    def rate(self, rate):
        self.con.setRate(rate) 

    def volume(self, volume):
        self.con.setVolume(volume) 
    
    def diameter(self, diameter):
        self.con.setDiameter(diameter)

    def getPumpStatus(self):
        return self.con.getPumpStatus()

    def getParameters(self):
        reponse = self.con.getParameters()
        return reponse

    def close(self):
        self.con.closeConnection()

class experiment():
    '''
    DESCRIPTION
        Main working class of the program... is responsible for file structure generation, loading a dictionary
        of available pumps and initializing them internally as Pump objects, based on the class above
        also requires the fill volume of syringes to auto stop any experiments before fluid is exhausted
        was imagined to be able to run multiple experiments, however, due to how the files are saved
        it makes more sense to "end" the class (closes the open serial connections to the pumps)
        and create a new iteration of the experiment class for new experiments or new trials

    ARGUMENTS:
        pump_dic (dic): pump dictionary generated by pump_tester() function

        pump1_max_vol (float): volume (mL) of fluid in syringe in syringe pump 1

        pump2_max_vol (float): volume (mL) of fluid in syringe in syringe pump 2
        
        overall_flow (float): overall flow out of the chip at the exit point in selected units
        
        equilibration_time (float): time between measurements allow for steady state flow to be achieved

        target_value (float): it is the value that the program will try to achieve 
                              try to achieve by varying dilution coniditions 
                              with the target_function_fitting method
        
        path123 (str): path to place where save files will be generated -- windows requires double \\ back slashes
        
        units (str): possible units to be used: 'mL/min', 'μL/min' -- all recorded values will be in those units -- pumps can accept 'mL/hr', 'μL/hr' versions of these units, but not implemented in this code
        
        syringe_diameter (float): diameter of syringe in mm -- can be obtained by selecting correct syringe on Fusion pump and copying it
    
        syringe_volume (float): overall volume of syringe in mL -- sets max volume pumped in syringe -- if not set, some pumps can set some random value e.g. 1 mL and stop pumping during during measurements

    OPTIONAL ARGUMENTS    
        _pumps (str): by default it is "ON", will initialize pumps and open COM ports
                      if it is set to any other string, it will not open COM ports
                      this is used to use this class to load data after experiments are complete

        communication_rate (int): baudrate used for serial connection -- 38400 set by default

        colour (str): by default = "R", selects which colour should be used for loading intensity values
                      from Ximea camera
                      if camera is black and white, needs to be set to "R"
                      if colour camera is used, possible options are: R, G, B, BW, 
                      for red, green, blue and black & white respectively, 
                      if in a colour camera e.g. B is selected, the blue channel will be used to load intensities
                      BW used a 1:1:1 average of RGB values
                      also "IN" can be added to any colour selected to use inverted intesities values 
                      (i.e. 255 - intesity)
                      as in: RIN, BIN, GIN, BWIN
        
        load_dic_path (str): path to pickle path_config file (need to give entire path, 
                             include name file with ".pkl" extension)
                             if given, class will populate its location dictionaries with 
                             locations from that experiment, enabling either loading of data for data analysis,
                             or enabling continuation of automated feature searching based on existing data set
                             (i.e. if automated feature searching has to be interrupted, it can be 
                             continued from last good data set using this feature
                             for more details see jupyter notebook)
        
    '''
    def __init__(self, pump_dic, pump1_max_vol, pump2_max_vol, overall_flow, equilibration_time, target_value, path123, units, syringe_diameter, syringe_volume, _pumps, communication_rate = 38400, colour = "R", load_dic_path = 0):

        #parent directory path
        self.path123 = path123

        # target value for FRR search --  not implemented for 4 pump version of program   
        self.target_value = target_value

        # time for equilibration aka steady state flow at measurement point
        self.equilibration_time = equilibration_time

        # data list for when program is used to confirm a pump power setting gives a certain reading
        # this assumes a linear fit of the map -- maps were found not to be linear
        self.estimating_pump1_power_data_list = []

        # parameters of a linear fit to a generated map -- in performed experiments, maps were found not be linear
        self.slope = 0
        self.intercept = 0
        self.r_value = 0
        self.std_err = 0

        # data list for finding certain value within mapped space using minimize_scalar from scipy.optimize 
        self.auto_fit_data_list = []

        # flag to remember if pumps are pumping -- would need individual pump flags to enable setting '0' as a possible pump power limit
        self.pumping_flag = False

        # colour channel used for loading intesity data
        self.colour = colour

        # number of iterations for peak/value searching function 
        self.auto_fit_call = 0

        # number of times test an estimated pump 1 power to generate a desired reading has been performed
        # part of the linear fitting methods
        # so is not necesarily very useful
        self.estimated_reading = 0

        self.units = units
        self.syringe_diameter = syringe_diameter
        self.syringe_volume = syringe_volume
        self.overall_flow = overall_flow
        self.pump_dic = pump_dic
        self.communication_rate = communication_rate
        
        # setting maximum volumes for syringes -- assumes values given were in mL
        if self.units == "mL/min":
            self.pump1_max_vol = pump1_max_vol
            self.pump2_max_vol = pump2_max_vol
        elif self.units == "μL/min":
            self.pump1_max_vol = pump1_max_vol*1000
            self.pump2_max_vol = pump2_max_vol*1000
                
        # pumped volume from syringe
        self.pump1_volume = 0
        self.pump2_volume = 0

        # total pumped volume from syring -- when program detects syringe will run out, it asks for syringe to be refilled
        # pump_volume is then reset to 0, while this value is kept, to know the total volume pumped through the whole experimental session
        self.pump1_totvol = 0
        self.pump2_totvol = 0

        # main data list header, used for recording what flow rates go with which data points
        self.data_list = [["units used = ", self.units,"overall pump rate", "pump1 rate", "pump2 rate", "flow ratio", "pump1 volume pumped", "pump2 volume pumped", "pump1 tot volume pumped", "pump2 tot volume pumped"]]

        if _pumps == "ON":
            # generates pump objects and pump_list ... sets appropriate diameter and units and max volume on syringe pump
            pump1 = Pump(pump_dic["1"],communication_rate) ## the one with  the dye
            pump2 = Pump(pump_dic["2"],communication_rate) ## dilution agent
            temp_list_p = [pump1, pump2]
            self.pump_list = temp_list_p
            self.pump1 = self.pump_list[0]
            self.pump2 = self.pump_list[1]
            for i in self.pump_list:
                i.diameter(self.syringe_diameter)
                i.units(self.units)
                i.volume(self.syringe_volume)

        # if path to path_config pickle file is given, then paths to different folders are loaded -- useful for using class to load data and to continue iterations of auto mapping function
        if load_dic_path != 0:
            with open(load_dic_path, "rb") as f:
                new_path_dic = pickle.load(f)
            self.path_fold = new_path_dic["path_fold"]
            self.map_name = new_path_dic["map_name"]
            self.path_fold_map = new_path_dic["path_fold_map"]
            self.auto_name = new_path_dic["auto_name"]
            self.path_fold_auto = new_path_dic["path_fold_auto"]
            self.testingmap_name = new_path_dic["testingmap_name"]
            self.path_fold_testingmap = new_path_dic["path_fold_testingmap"]
        
        else:
            # generates folder structure and saves it as appropriate attributes
            folder_name = "Simple Pumpkin Experiment " + str(date.today())
            path_fold = os.path.join(self.path123, folder_name)
            self.path_fold = path_fold
            try:
                os.makedirs(path_fold)
            except:
                pass

            map_name = "map " + str(datetime.now().hour) + "." + str(datetime.now().minute)
            self.map_name = map_name
            path_fold_map = os.path.join(path_fold, map_name)
            self.path_fold_map = path_fold_map
            os.mkdir(path_fold_map)

            auto_name = "auto_fit " + str(datetime.now().hour) + "." + str(datetime.now().minute)
            self.auto_name = auto_name
            path_fold_auto = os.path.join(path_fold, auto_name)
            self.path_fold_auto = path_fold_auto
            os.mkdir(path_fold_auto)

            # this folder structure was used for the methods that would test the validity of a linear fit
            testingmap_name = "testingmap " + str(datetime.now().hour) + "." + str(datetime.now().minute)
            self.testingmap_name = testingmap_name
            path_fold_testingmap = os.path.join(path_fold, testingmap_name)
            self.path_fold_testingmap = path_fold_testingmap
            os.mkdir(path_fold_testingmap)

            # saves a pickle file of the different paths, so that the class can be used to load data easily
            path_config_name = "path_config " + str(datetime.now().hour) + "." + str(datetime.now().minute)
            path_to_path_config = os.path.join(path_fold, path_config_name)
            path_to_path_config = path_to_path_config + ".pkl"

            path_dic = {"path_fold": self.path_fold, "map_name": self.map_name, "path_fold_map": self.path_fold_map, "auto_name": self.auto_name, "path_fold_auto": self.path_fold_auto, "testingmap_name": self.testingmap_name, "path_fold_testingmap": self.path_fold_testingmap}

            with open(path_to_path_config, "wb") as f:
                pickle.dump(path_dic, f)


    def end(self):
        '''closes the open COM connections of the pumps'''
        for i in self.pump_list:
            i.close()

    def runall(self):
        """turns on all the pumps"""
        if self.pumping_flag == False:
            for j in self.pump_list:
                j.run()
            self.pumping_flag = True
    
    def stopall(self):
        """stops all the pumps"""
        for i in self.pump_list:
            i.stop()
        self.pumping_flag = False

    def set_units(self, units):
        """sets units of all the pumps"""
        for i in self.pump_list:
            i.units(units)

    def set_diameter(self, diameter):
        """sets diameter of all the pumps"""
        for i in self.pump_list:
            i.diameter(diameter)

    def update_vol(self, pump1rate, pump2rate, time_to_run):
        '''updates the self.volume atributes of the class'''
        self.pump1_volume = self.pump1_volume + pump1rate*(time_to_run/60)
        self.pump2_volume = self.pump2_volume + pump2rate*(time_to_run/60)

        self.pump1_totvol = self.pump1_totvol + pump1rate*(time_to_run/60)
        self.pump2_totvol = self.pump2_totvol + pump2rate*(time_to_run/60)

    def check_volume_to_pump(self, pump1rate, pump2rate, time_to_run):
        '''checks to see if there is enough reactant in the pumps to complete the next set of pumping'''
        future_pump1_vol = self.pump1_volume + pump1rate*(time_to_run/60)
        future_pump2_vol = self.pump2_volume + pump2rate*(time_to_run/60)
        if (future_pump1_vol < self.pump1_max_vol) and (future_pump2_vol < self.pump2_max_vol):
            return True
        else:
            return False
    
    def reset_volume(self):
        '''allows for updating of the volume inside the syringes'''
        new_pump1_vol = float(input("pump 1 new volume:"))
        new_pump2_vol = float(input("pump 2 new volume:"))
        self.pump1_volume = 0
        self.pump2_volume = 0
        if self.units == "mL/min":
            self.pump1_max_vol = new_pump1_vol
            self.pump2_max_vol = new_pump2_vol
        elif self.units == "μL/min":
            self.pump1_max_vol = new_pump1_vol*1000
            self.pump2_max_vol = new_pump2_vol*1000


    def totvolume_pumped(self, name):
        '''returns the total volume pumped by pump 1 or 2'''
        if name == 1:
            volume = self.pump1_totvol
        elif name == 2:
            volume = self.pump2_totvol
        return volume
    
    def volume_pumped(self, time_to_run, rate):
        """calculates volume pumped by pump"""
        volume = (time_to_run/60)*rate
        return volume

    def append_vol(self, temp_list, time_to_run, pump1rate, pump2rate):
        """appends a inputed list with the pumped volumes by each pump and the total pumped volumes of each pump"""
        temp_list.append(self.volume_pumped(time_to_run, pump1rate))
        temp_list.append(self.volume_pumped(time_to_run, pump2rate))
        temp_list.append(self.totvolume_pumped(1))
        temp_list.append(self.totvolume_pumped(2))   


    def take_reading(self, attempt_num): ## pos starts at 0 and goes up up to num of position folders
        """ 
        Summary:
            takes reading of intensity... assumes Ximea CamTool is fullscreen on a 4k display
            takes control of keyboard and mouse to do this -- assumes line profile is displaying on lower section of display
            computer cannot be in use while doing this
            sleep times are there to ensure smooth operation -- cannot click things too fast, doesn't work

        Arguments:
            attempt_num (str or int): save file name
        """
        pyautogui.hotkey('ctrl','s')
        time.sleep(0.3) ## needs to be here to allow window animation to finish
        pyautogui.typewrite(str(attempt_num))
        time.sleep(0.1)
        pyautogui.press("enter")
        time.sleep(0.1)
        
        pos2 = 563, 1721          
        pyautogui.moveTo(pos2)
        time.sleep(0.1)
        pyautogui.click()
        time.sleep(0.1)
        pyautogui.typewrite(str(attempt_num))
        time.sleep(0.1)
        pyautogui.press("enter")



    def get_reading(self, path, colour):
        """
        Summary:
            loads intesity line profile
        
        Arguments:
            path (str): path to .txt file to be read
            colour (str): which colour channel should be read from line profile
        """
        crosssec_initial_load = np.loadtxt(path, skiprows = 1)
        if colour == "R":
            crosssec_final_load = crosssec_initial_load[:,1]
        elif colour == "G":
            crosssec_final_load = crosssec_initial_load[:,2]
        elif colour == "B":
            crosssec_final_load = crosssec_initial_load[:,3]
        elif colour == "BW":
            crosssec_bw = (crosssec_initial_load[:,1] + crosssec_initial_load[:,2] + crosssec_initial_load[:,3])/3
            crosssec_final_load = crosssec_bw
        elif colour == "BWIN":
            crosssec_bwin = ((crosssec_initial_load[:,1] + crosssec_initial_load[:,2] + crosssec_initial_load[:,3])/(-3))+256
            crosssec_final_load = crosssec_bwin
        elif colour == "RIN":
            crosssec_Rin = crosssec_initial_load[:,1]*-1 + 255
            crosssec_final_load = crosssec_Rin
        elif colour == "GIN":
            crosssec_Gin = crosssec_initial_load[:,2]*-1 + 255
            crosssec_final_load = crosssec_Gin
        elif colour == "BIN":
            crosssec_Bin = crosssec_initial_load[:,3]*-1 + 255
            crosssec_final_load = crosssec_Bin
        else:
            crosssec_final_load = crosssec_initial_load
        return crosssec_final_load



    def aim_ximea(self, path):
        """ 
        Summary:
            uses mouse and keyboard to aim ximea CamTool program to folder given by path parameter
        Arguments:
            path (str): path to which Ximea CamTool should be directed towards (so that it saves files there)
        """
        time.sleep(3)
        pos2 = 563, 1721          
        pyautogui.moveTo(pos2)
        pyautogui.click()
        pos3 = 1690, 171          
        pyautogui.moveTo(pos3)
        time.sleep(2)
        pyautogui.click()
        time.sleep(0.1)
        pyautogui.typewrite(str(path))
        time.sleep(3)
        pyautogui.press("enter")
        time.sleep(0.2)
        pos4 = 1338, 1290
        pyautogui.moveTo(pos4)
        time.sleep(0.2)
        pyautogui.click()
        number = random.randrange(0,1000)
        name = "aiming" + str(number)
        pyautogui.typewrite(str(name))
        time.sleep(0.2)
        pyautogui.press("enter")
        wn.Beep(500,450)

    
    def steady_state_time_finder(self, pump1_power = 0.5, step = -0.25):
        """ 
        Summary:
            method written to make finding steady state equilibration time finding easier... 
            sets a certain FRR for both sets of pumps and waits for input ... 
            after input, FRR are changed, and timer is started
            after another input, when steady steady is achieved, timer is stopped along with pumps
        
        Optional Arguments:
            pump1_power (float): initial pump1 power from >0 - 1 
            pump3_power (float): initial pump3 power from >0 - 1 
            step (float): by how much pump 1 and pump 3 power should increase after first input
        """

        pump1rate = (self.overall_flow)*pump1_power
        pump2rate = (self.overall_flow) - pump1rate
        self.pump1.rate(pump1rate)
        self.pump2.rate(pump2rate)
        self.runall()
        input("ready to start timed trial? \n Press any key to initiate change of FRR")
        pump1rate = (self.overall_flow)*(pump1_power + step)
        pump2rate = (self.overall_flow) - pump1rate
        tik = time.perf_counter()
        self.pump1.rate(pump1rate)
        self.pump2.rate(pump2rate)
        wn.Beep(650,400)
        input("Press enter when steady state has been reached")
        tok = time.perf_counter()
        self.stopall()
        wn.Beep(477,389)
        self.equilibration_time = tok - tik
        print("The measured steady state equilibration time was: " + str(round((tok - tik),5)))
        print("The new equilibration time is therefore " + str(self.equilibration_time))
        



        # pump1_power is a parameter from 0 to 1, determining how much of the overall flow is pump1 i.e. 0 is 0, 1 is only pump1
        # pump power has to be >0, <1
    def pumping(self, pump1_power, initial_wait_flag):
        """ 
        Summary:
            method meant for internal use only, sets appropriate pumping rates and starts pumps, as well as checking if there is enough volume in syringes
            waits equilibration_time amout of time before continuing
            also returns some list with pump rates and FRRs
        """
        pump1rate = (self.overall_flow)*pump1_power
        pump2rate = (self.overall_flow) - pump1rate
        self.pump1.rate(pump1rate)
        self.pump2.rate(pump2rate)
        temp_list = []
        temp_list.append(self.overall_flow)
        temp_list.append((pump1rate))
        temp_list.append((pump2rate))
        temp_list.append((pump1rate/pump2rate))

        if self.check_volume_to_pump(pump1rate, pump2rate, self.equilibration_time) == False:
            self.stopall()
            wn.Beep(1500,1000)
            wn.Beep (1350, 1000)
            wn.Beep (1600, 1000)
            input("you need to refil the syringes, press enter to continue")
            self.reset_volume()
            initial_wait_flag = False

        tik = time.perf_counter()
        self.runall()
        time.sleep(self.equilibration_time)
        wn.Beep(500,500)
        wn.Beep(700,300)
        return pump1rate, pump2rate, tik, temp_list, initial_wait_flag







    def map_the_space(self, bounds, n_samples, reverse_flag, sample_collection_flag):
        """ 
        Summary:
            function to generate a map of the 2 pump FRR space with linear pump power spacing
            i.e. linear concentrations spacing
            Saves files, doesn't do anything else
            bounds1 are a tupel of minimum and maximum pump1_power respectively (which overall can be from <0 to 1) ## giving pump power 0 does not function
            n1_samples are the number of samples to be taken in the pump 1 space 
        
        Arguments:
            bounds (tupel): minimum and maximum pump1_power (from >0 to 1)
            
            n_samples (int): number of steps to be taken to map the pump 1 space
            
            reverse_flag (boolean): if True, will start with highest values in pump 1 space, if False, will start with lowest values
                                        this is a mediocre implementation of this, it is better handled in the later methods
        """
        step = (bounds[1] - bounds[0])/(n_samples-1)
        initial_wait_flag = False
        for i in range(n_samples):
            if reverse_flag == False:
                pump1_power = bounds[0] + i*step
            if reverse_flag == True:
                pump1_power = bounds[1] - i*step

            pump1rate, pump2rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, initial_wait_flag)
            flow_ratio = (pump1rate)/(pump2rate)
            if initial_wait_flag == False:
                time.sleep(self.equilibration_time)
                #time.sleep(self.equilibration_time)
                initial_wait_flag = True
            self.take_reading("FRR " + str(round(flow_ratio, 5)))
            if sample_collection_flag == True:
                wn.Beep(878,600)
                wn.Beep(878,600)
                wn.Beep(878,600)
                time.sleep(self.equilibration_time)
                wn.Beep(670,600)
            tok = time.perf_counter()
            self.update_vol(pump1rate, pump2rate, (tok-tik))
            self.append_vol(temp_list, (tok-tik), pump1rate, pump2rate)
            self.data_list.append(temp_list)

            data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
            np.savetxt(data_file, (self.data_list)[1:], header = (str(self.data_list[0])))
            wn.Beep(777,687)
        
        self.stopall()

    def map_the_space_input_FRR_array(self, FRR_array, reverse_flag, sample_collection_flag):
        """ 
        Summary:
            function to generate a map of the 2 pump FRR space with manually inputted FRRs
            i.e. manually specify the flow rate ratios of the pumps
            Saves files, doesn't do anything else
            
        Arguments:
            FRR_array (list type): list of the flow rate ratios of pump 1 to pump 2 to be tested (from >0 to <inf)
            
            reverse_flag (boolean): if True, will start with highest values in pump 1 space, if False, will start with lowest values
                                        this is a mediocre implementation of this, it is better handled in the later methods

            sample_collection_flag (boolean): if True, after equilibrium is reached, pumps will continue pumping for an aditional "equilibration_time" 
                                              so that liquid samples can be collected
                                              the computer will beep 3 times when collection time starts
                                              and beep once when time is over
        """
        initial_wait_flag = False
        for i in FRR_array:
            flow_ratio = i
            if reverse_flag == False:
                pump1_power = (flow_ratio/(1+flow_ratio))
            
            if reverse_flag == True:
                pump1_power = 1 - (flow_ratio/(1+flow_ratio))

            pump1rate, pump2rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, initial_wait_flag)
            flow_ratio = (pump1rate)/(pump2rate)
            if initial_wait_flag == False:
                time.sleep(self.equilibration_time)
                #time.sleep(self.equilibration_time)
                initial_wait_flag = True
            self.take_reading("FRR " + str(round(flow_ratio, 5)))
            if sample_collection_flag == True:
                wn.Beep(878,600)
                wn.Beep(878,600)
                wn.Beep(878,600)
                time.sleep(self.equilibration_time)
                wn.Beep(670,600)
            tok = time.perf_counter()
            self.update_vol(pump1rate, pump2rate, (tok-tik))
            self.append_vol(temp_list, (tok-tik), pump1rate, pump2rate)
            self.data_list.append(temp_list)

            data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
            np.savetxt(data_file, (self.data_list)[1:], header = (str(self.data_list[0])))
            wn.Beep(777,687)
        
        self.stopall()

        
    def load_the_map(self, colour, path = None):
        """
        Summary:
            loads the map i.e. the FRR data along with intensity measurements
        
        Optional Arguments:
            colour (str): selects which colour channel to use for intensity measurements ...  use "R" for BW camera

        Return:
            pump1_power (numpy array): array of applied pump 1 power
            flow_ratios (numpy array): array of applied flow rate ratios of pump 1 to pump 2
            intensity (numpy array): array of measured intensity
        """
        data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
        list_of_intsity = []
        for flow_ratio in np.loadtxt(data_file, skiprows = 1)[:,3]:
            flow_ratio = round(flow_ratio, 5)
            if path == None:
                data_path_of_map_files = str(self.path_fold_map) + "\\FRR " + str(flow_ratio) + ".txt"
            else:
                data_path_of_map_files = str(path) + "\\FRR " + str(flow_ratio) + ".txt"
            raw_crosssec = self.get_reading(data_path_of_map_files, colour)
            temp_list = []
            average_intensity = np.mean(raw_crosssec)
            temp_list.append(flow_ratio)
            temp_list.append(average_intensity)
            list_of_intsity.append(temp_list)
        intensity_array = np.array(list_of_intsity)
        flow_ratios = np.array(intensity_array[:,0])
        intensity = np.array(intensity_array[:,1])
        pump1_power = np.array(np.loadtxt(data_file, skiprows = 1)[:,1])

        return pump1_power, flow_ratios, intensity
    
    def linear_fit_of_map(self, colour, path = None):
        """
        Summary:
            Applied a linear fit to the currently collected or loaded map, set slope, intercept, r_value and str_err values
        Arguments:
            colour (str): colour channel to be used for the fitting
        Optional Arguments:
            path (str): path to be fed to the load_the_map method used internally
        Return:
            slope, intercept, r_value, std_err of the linear fit
        """
        pump1_power, flow_ratios, intensity = self.load_the_map(colour, path)
        slope, intercept, r_value, p_value, std_err = stats.linregress(pump1_power, intensity)
        print("your r value (Pearson correlation coefficient) and standard error are \n" \
              + str(r_value) + " ,  " + str(std_err))
        self.slope = slope
        self.intercept = intercept
        self.r_value = r_value
        self.std_err = std_err
        return slope, intercept, r_value, std_err
    
    def linfit_based_on_map(self, x):
        """
        Summary: 
            m*x + c function with slope and intercept taken form the internal values
        """
        y_val = (self.slope)*x+(self.intercept)
        return y_val
    
    def estimate_needed_pump1_power(self, target):
        """
        Summary:
            estimates the required pump 1 power needed to reach a target sensor reading (intesity) 
            based on the linear fit of a loaded/collected map
        """
        pump1_power = (target - self.intercept)/(self.slope)
        return pump1_power

    def plot_map(self, colour, path = None):
        """
        Summary:
            Plots loaded or collected Map (Sensor reading vs Pump 1 Power)

        Arguments:
            colour (str): colour channel to be used for the map loading
        """
        pump1_power, flow_ratios, intensity = self.load_the_map(colour, path)
        plt.plot(pump1_power, intensity, linestyle = "", marker = "*")
        x = np.linspace(pump1_power[0], pump1_power[-1], 100)
        y = self.linfit_based_on_map(x)
        plt.plot(x, y)
        titlestr = "Abs Flow " + str(self.overall_flow) + " " + str(self.units) + " : Measured Intensity vs Pump 1 Power"
        plt.title(titlestr)
        plt.xlabel("Pump 1 Power")
        plt.ylabel("Measured Intensity")
        plt.show()


    def test_estimated_reading(self, target = 0, colour = "R"):
        """
        Summary:
            Calculates a FRR needed to reach the target value based on a linear fit of a collected/loaded map
            Performs a measurement of the actual value at that FRR
            Prints out that measurement and how far it was from the target value

        Optional Arguments:
            target (float): target sensor value, if left unpopulated, will use the initially defined target value

        """
        self.estimated_reading += 1
        if target == 0:
            target = self.target_value
        
        estimated_pump1_power = round(self.estimate_needed_pump1_power(target),5)
        self.aim_ximea(self.path_fold_testingmap)
        initial_wait_flag = False
        pump1rate, pump2rate, tik, temp_list = self.pumping(estimated_pump1_power, initial_wait_flag)
        if initial_wait_flag == False:
            time.sleep(self.equilibration_time)
            #time.sleep(self.equilibration_time)
            initial_wait_flag = True

        self.take_reading("Estimated reading p1 power " + str(estimated_pump1_power))
        self.stopall()
        tok = time.perf_counter()
        self.update_vol(pump1rate, pump2rate, (tok-tik))
        self.append_vol(temp_list, (tok-tik), pump1rate, pump2rate)
        temp_list.append(target)

        ### get the reading
        data_path_of_estimate_file = str(self.path_fold_testingmap) + "\\Estimated reading p1 power " + str(estimated_pump1_power) + ".txt"
        mean_intensity = np.mean(self.get_reading(data_path_of_estimate_file, colour))
        temp_list.append(mean_intensity)

        self.estimating_pump1_power_data_list.append(temp_list)  
        data_file = str(self.path_fold) + "\\Estimated pump1 power " + str(self.estimated_reading) + ".txt"
        np.savetxt(data_file, temp_list, header = (str(str(self.data_list[0]) + "target value, reading of camera")))
        wn.Beep(777,687)
        print("your target input was " + str(target) + "\n" + \
              "the calculated pump 1 power for this target was " + str(estimated_pump1_power) + "\n" + \
              "the reading from the stereoscope was " + str(mean_intensity) + \
              "this is off by " + str((target - mean_intensity)))
        if abs(target - mean_intensity) < 3:
            print("Nice!")
        else:
            print("well... at least this program works")



    def minimize_fit_internal_func(self, pump1_power):
        """
        Summary:
            Method meant for internal use in the target_finding_function method
            It simply takes one input, of pump power, and returns the difference between the measured sensor reading 
            and the internally defined target value
        """
        if self.pumping_flag == False:
            initial_wait_flag = False
        self.auto_fit_call += 1
        temp2 = []
        temp2.append(pump1_power)
        pump1rate, pump2rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, initial_wait_flag)
        print("Your FRR is: " + str(pump1rate/pump2rate))

        if initial_wait_flag == False:
            time.sleep(self.equilibration_time)
            #time.sleep(self.equilibration_time)
            initial_wait_flag = True

        self.take_reading("auto fit FRR " + str(self.auto_fit_call))
        tok = time.perf_counter()
        self.update_vol(pump1rate, pump2rate, (tok-tik))

        ### get the reading
        data_path = str(self.path_fold_auto) + "\\auto fit FRR " + str(self.auto_fit_call) + ".txt"
        colour = self.colour
        time.sleep(0.5) ### i really don't think this needs to be here, but it resolved a 'file not found' error, or maybe the error resolved itself, and its unncessary
        mean_intensity = np.mean(self.get_reading(data_path, colour))
        temp2.append(mean_intensity)
        self.auto_fit_data_list.append(temp2)
        dif = abs(mean_intensity-self.target_value)
        wn.Beep(576,534)
        return dif



    def target_finding_function(self, mybounds = (0.001, 0.999), x_atol = (0.02), maxiter = 7):
        """
        Summary:
            Method meant to get the program to find the correct pump power to have a specific readout of the sensor
            Uses the interanally defined target value
            Uses a quadratic fit iterator minimize_scalar from scipy.optimize package
            Does not use any previously defined map, searches blind every time
            Saves the pump power applied and the measured sensor readout
        
        Optional Arguments:
            mybounds (tupel): bounds for possible pump power, need to be >0, <1

            x_atol (float): the absolute tolerance of the searching algorithm in the x - axis
                            i.e. it will search within x_atol (e.g. 0.02) on pump power for the target value
            
            maxiter (int): maximum number of allowed iterations before termination
        """
        opt_dic = {'xatol': x_atol, 'maxiter': maxiter}

        self.aim_ximea(self.path_fold_auto)

        #this does the actual fitting
        minimize_scalar(self.minimize_fit_internal_func, bounds = mybounds, method='bounded', options = opt_dic)
        
        temp_save_data_list = [["pump 1 power", "sensor reading"]]
        temp_save_data_list.append(self.auto_fit_data_list)
        data_file = str(self.path_fold) + "\\target fitting dataset itr " + str(self.auto_fit_call) + ".txt"
        np.savetxt(data_file, (temp_save_data_list)[1:], header = (str(temp_save_data_list[0])))
        print(str(self.auto_fit_data_list))
        self.auto_fit_data_list = []
        print('Sensor setpoint: '+str(self.target_value))
        print('Optimised sensor reading: '+str(self.auto_fit_data_list[-1]))



    def peak_finding_internal_func(self, pump1_power):
        """
        Summary:
            Method meant for internal use in the peak_finding_function method
            It simply takes one input, of pump power, and returns the difference between the measured sensor reading 
            and the internally defined target value
        """
        print(self.pumping_flag)
        if self.pumping_flag == False:
            initial_wait_flag = False
        else:
            initial_wait_flag = True
        self.auto_fit_call += 1
        temp2 = []
        temp2.append(pump1_power)
        pump1rate, pump2rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, initial_wait_flag)
        print("Your FRR is: " + str(pump1rate/pump2rate))

        if initial_wait_flag == False:
            time.sleep(self.equilibration_time)
            #time.sleep(self.equilibration_time)
            initial_wait_flag = True

        self.take_reading("auto fit FRR " + str(self.auto_fit_call))
        tok = time.perf_counter()
        self.update_vol(pump1rate, pump2rate, (tok-tik))

        ### get the reading
        data_path = str(self.path_fold_auto) + "\\auto fit FRR " + str(self.auto_fit_call) + ".txt"
        colour = self.colour                                           ## it did NOT resolve it
        time.sleep(1) ### i really don't think this needs to be here, but it resolved a 'file not found' error, or maybe the error resolved itself, and its unncessary
        mean_intensity = np.mean(self.get_reading(data_path, colour))
        temp2.append(mean_intensity)
        self.auto_fit_data_list.append(temp2)
        wn.Beep(576,534)
        negative_mean_intensity = -mean_intensity
        return negative_mean_intensity



    def peak_finding_function(self, mybounds = (0.001, 0.999), x_atol = (0.02), maxiter = 7):
        """
        Summary:
            Method meant to get the program to find the correct pump power to fit peak in the sensor readout
            Uses a quadratic fit iterator minimize_scalar from scipy.optimize package
            Does not use any previously defined map, searches blind every time
            Saves the pump power applied and the measured sensor readout
        
        Optional Arguments:
            mybounds (tupel): bounds for possible pump power, need to be >0, <1

            x_atol (float): the absolute tolerance of the searching algorithm in the x - axis
                            i.e. it will search within x_atol (e.g. 0.02) on pump power for the target value
            
            maxiter (int): maximum number of allowed iterations before termination
        """

        opt_dic = {'xatol': x_atol, 'maxiter': maxiter}
        self.aim_ximea(self.path_fold_auto)
        
        #this does the actual fitting
        minimize_scalar(self.peak_finding_internal_func, bounds = mybounds, method='bounded', options = opt_dic)
        
        temp_save_data_list = [["pump 1 power", "sensor reading"]]
        temp_save_data_list.append(self.auto_fit_data_list)
        data_file = str(self.path_fold) + "\\peak finding dataset itr " + str(self.auto_fit_call) + ".txt"
        np.savetxt(data_file, (temp_save_data_list)[1:], header = (str(temp_save_data_list[0])))
        print(str(self.auto_fit_data_list))
        self.auto_fit_data_list = []
        print('Optimised sensor reading: '+str(self.auto_fit_data_list[-1]))


