from connect import *
from datetime import datetime
from pathlib import Path
import os 
import time
import winsound as wn
import numpy as np
import pyautogui
from datetime import date
from scipy import stats
from scipy import optimize
import random
import pickle
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar
from scipy.interpolate import CubicSpline
from sklearn import linear_model


# Hello and welcome to my 4 pump auto experiement code
# sorry for any wrong spelling --  no autocorrect in VS Code
# Ignacy Bartnik


def pump_tester(baudrate = 38400): 
    '''
    Summary:
        uses connect.py from pump manufacturer website to check for open serial ports
        and then generate and return a list of pumps and ports
        
        need to define pumps with numbers 1 - 4, pump 1 and pump 3 have chemicals, 
        pump 2 and 4 contain dilution agents
        
        DOES NOT WORK ON WINDOWS IF BLUETOOTH TURNED ON
        (gets stuck on bluetooth COM ports)
    Optional Arguments:
        baudrate (int): baudrate used for communication with Chemyx Fusion Pumps    
    '''
    pump_dic = {}
    ports = getOpenPorts()
    print("available COM ports are:", ports)
    for i in ports:
        pump = Pump(i, baudrate)
        pump.run()
        time.sleep(1)
        pump.stop()
        print("this was port:", i)
        connected_input = input("Is it connected to a pump? (enter for yes, any button for no):")
        if connected_input == "":
            print("it is pump number:")
            pump_number = input()
            pump_dic.update({str(pump_number):str(i)})
    return pump_dic




class Pump(object):
    '''
    Description:
        class used to control pumps
        to make multiple commands to pumps go faster, it keeps the connection open 
        until told otherwise
        also relies on the connect.py import, like everything in this project

    Arguments:
        port (str): COM port to which pump is connected e.g. "COM7"
    
    '''
    def __init__(self, port, communication_rate = 38400):
        self.port = port
        self.baudrate = communication_rate
        self.con = Connection(self.port, self.baudrate)
        self.con.openConnection()
    
    def run(self):
        self.con.startPump()

    def pause(self):
        self.con.pausePump()

    def stop(self):
        self.con.stopPump()
    
    def units(self, units):
        self.con.setUnits(units) 

    def rate(self, rate):
        self.con.setRate(rate) 

    def volume(self, volume):
        self.con.setVolume(volume) 
    
    def diameter(self, diameter):
        self.con.setDiameter(diameter)

    def getPumpStatus(self):
        return self.con.getPumpStatus()

    def getParameters(self):
        reponse = self.con.getParameters()
        return reponse

    def close(self):
        self.con.closeConnection()

class complex_experiment():
    '''
    DESCRIPTION
        Main working class of the program... is responsible for file structure generation, loading a dictionary
        of available pumps and initializing them internally as Pump objects, based on the class above
        also requires the fill volume of syringes to auto stop any experiments before fluid is exhausted
        was imagined to be able to run multiple experiments, however, due to how the files are saved
        it makes more sense to "end" the class (closes the open serial connections to the pumps)
        and create a new iteration of the complex_experiment class for new experiments or new trials

    ARGUMENTS:
        pump_dic (dic): pump dictionary generated by pump_tester() function

        pump1_max_vol (float): volume (mL) of fluid in syringe in syringe pump 1

        pump2_max_vol (float): volume (mL) of fluid in syringe in syringe pump 2

        pump3_max_vol (float): volume (mL) of fluid in syringe in syringe pump 3
        
        pump4_max_vol (float): volume (mL) of fluid in syringe in syringe pump 4
        
        overall_flow (float): overall flow out of the chip at the exit point in selected units
        
        equilibration_time (float): time between measurements allow for steady state flow to be achieved
        
        target_value (float): antiquated value from 2 pump program: it is the value that the program would
                              try to achieve by varying dilution coniditions -- not implemented in 4 pump system
        
        path123 (str): path to place where save files will be generated -- windows requires double \\ back slashes
        
        units (str): possible units to be used: 'mL/min', 'μL/min' -- all recorded values will be in those units
                      -- pumps can accept /hr versions of these units, but not implemented in this code
        
        syringe_diameter (float): diameter of syringe in mm -
                                  - can be obtained by selecting correct syringe on Fusion pump and copying it
    
        syringe_volume (float): overall volume of syringe in mL -- sets max volume pumped in syringe -
                                - if not set, some pumps can set some random value e.g. 1 mL 
                                and stop pumping during during measurements

    OPTIONAL PARAMETERS    
        _pumps (str): by default it is "ON", will initialize pumps and open COM ports
                      if it is set to any other string, it will not open COM ports
                      this is used to use this class to load data after experiments are complete

        communication_rate (int): baudrate used for serial connection -- 38400 set by default

        colour (str): by default = "R", selects which colour should be used for 
                      loading intensity values from Ximea camera
                      if camera is black and white, needs to be set to "R"
                      if colour camera is used, possible options are: R, G, B, BW, 
                      for red, green, blue and black & white respectively, 
                      if in a colour camera e.g. B is selected, the blue channel will be used to load intensities
                      BW used a 1:1:1 average of RGB values
                      also "IN" can be added to any colour selected to use inverted intesities values 
                      (i.e. 255 - intesity) as in: RIN, BIN, GIN, BWIN
        
        load_dic_path (str): path to pickle path_config file 
                             (need to give entire path, include name file with ".pkl" extension)
                             if given, class will populate its location dictionaries with locations 
                             from that experiment, enabling either loading of data for data analysis,
                             or enabling continuation of automated feature searching based on existing data set
                             (i.e. if automated feature searching has to be interrupted, it can be continued 
                             from last good data set using this feature: for more details see jupyter notebook)
        
    '''
    def __init__(self, pump_dic, pump1_max_vol, pump2_max_vol, pump3_max_vol, pump4_max_vol, overall_flow, equilibration_time, target_value, path123, units, syringe_diameter, syringe_volume, _pumps = "ON", communication_rate = 38400, colour = "R", load_dic_path = 0):

        #parent directory path
        self.path123 = path123

        # target value for FRR search --  not implemented for 4 pump version of program   
        self.target_value = target_value

        # time for equilibration aka steady state flow at measurement point
        self.equilibration_time = equilibration_time

        # data list for finding certain value within mapped space using minimize_scalar from scipy.optimize 
        self.auto_fit_data_list = []

        # flag to remember if pumps are pumping -- would need individual pump flags to enable setting '0' as a possible pump power limit
        self.pumping_flag = False

        # colour channel used for loading intesity data
        self.colour = colour

        # number of iterations for peak/value searching function 
        self.auto_fit_call = 0

        self.syringe_volume = syringe_volume
        self.units = units
        self.syringe_diameter = syringe_diameter
        self.overall_flow = overall_flow
        self.pump_dic = pump_dic
        self.communication_rate = communication_rate

        self.pump1power_internal = 0
        self.pump3power_internal = 0

        # setting maximum volumes for syringes -- assumes values given were in mL
        if self.units == "mL/min":
            self.pump1_max_vol = pump1_max_vol
            self.pump2_max_vol = pump2_max_vol
            self.pump3_max_vol = pump3_max_vol
            self.pump4_max_vol = pump4_max_vol
        elif self.units == "μL/min":
            self.pump1_max_vol = pump1_max_vol*1000
            self.pump2_max_vol = pump2_max_vol*1000
            self.pump3_max_vol = pump3_max_vol*1000
            self.pump4_max_vol = pump4_max_vol*1000
        
        # pumped volume from syringe
        self.pump1_volume = 0
        self.pump2_volume = 0
        self.pump3_volume = 0
        self.pump4_volume = 0
        
        # total pumped volume from syring -- when program detects syringe will run out, it asks for syringe to be refilled
        # pump_volume is then reset to 0, while this value is kept, to know the total volume pumped through the whole experimental session
        self.pump1_totvol = 0
        self.pump2_totvol = 0
        self.pump3_totvol = 0
        self.pump4_totvol = 0

        # main data list header, used for recording what flow rates go with which data points
        self.data_list = [["units used = ", self.units,"overall pump rate", "pump1 rate", "pump2 rate", "pump3 rate", "pump4 rate", "flow ratio1", "flow ratio2", "flow ratio3", "pump1 volume pumped", "pump2 volume pumped", "pump3 volume pumped", "pump4 volume pumped", "pump1 tot volume pumped", "pump2 tot volume pumped", "pump3 tot volume pumped", "pump4 tot volume pumped"]]
        
        if _pumps == "ON":
            # generates pump objects and pump_list ... sets appropriate diameter and units and max volume on syringe pump
            pump1 = Pump(pump_dic["1"],communication_rate) ## the one with  the dye
            pump2 = Pump(pump_dic["2"],communication_rate) ## dilution agent
            pump3 = Pump(pump_dic["3"],communication_rate) ## the one with  the dye
            pump4 = Pump(pump_dic["4"],communication_rate) ## dilution agent
            self.pump_list = [pump1, pump2, pump3, pump4]
            self.pump1 = self.pump_list[0]
            self.pump2 = self.pump_list[1]
            self.pump3 = self.pump_list[2]
            self.pump4 = self.pump_list[3]
            for i in self.pump_list:
                i.diameter(self.syringe_diameter)
                i.units(self.units)
                # never tested this feature -- might not work
                i.volume(self.syringe_volume)


        # if path to path_config pickle file is given, then paths to different folders are loaded -- useful for using class to load data and to continue iterations of auto mapping function
        if load_dic_path != 0:
            with open(load_dic_path, "rb") as f:
                new_path_dic = pickle.load(f)
            self.path_fold = new_path_dic["path_fold"]
            self.map_name = new_path_dic["map_name"]
            self.path_fold_map = new_path_dic["path_fold_map"]
            self.auto_name = new_path_dic["auto_name"]
            self.path_fold_auto = new_path_dic["path_fold_auto"]
            self.testingmap_name = new_path_dic["testingmap_name"]
            self.path_fold_testingmap = new_path_dic["path_fold_testingmap"]
        
        else:
            # generates folder structure and saves it as appropriate attributes
            folder_name = "Complex Pumpkin Experiment " + str(date.today())
            path_fold = os.path.join(self.path123, folder_name)
            self.path_fold = path_fold
            try:
                os.makedirs(path_fold)
            except:
                print("I didn't make the initial folder")
            map_name = "map " + str(datetime.now().hour) + "." + str(datetime.now().minute)
            self.map_name = map_name
            path_fold_map = os.path.join(path_fold, map_name)
            self.path_fold_map = path_fold_map
            os.mkdir(path_fold_map)

            auto_name = "auto_fit " + str(datetime.now().hour) + "." + str(datetime.now().minute)
            self.auto_name = auto_name
            path_fold_auto = os.path.join(path_fold, auto_name)
            self.path_fold_auto = path_fold_auto
            os.mkdir(path_fold_auto)

            # this folder structure is actually not used by anything... but is used in the 2 pump version
            testingmap_name = "testingmap " + str(datetime.now().hour) + "." + str(datetime.now().minute)
            self.testingmap_name = testingmap_name
            path_fold_testingmap = os.path.join(path_fold, testingmap_name)
            self.path_fold_testingmap = path_fold_testingmap
            os.mkdir(path_fold_testingmap)

            # saves a pickle file of the different paths, so that the class can be used to load data easily
            path_config_name = "path_config " + str(datetime.now().hour) + "." + str(datetime.now().minute)
            path_to_path_config = os.path.join(path_fold, path_config_name)
            path_to_path_config = path_to_path_config + ".pkl"

            path_dic = {"path_fold": self.path_fold, "map_name": self.map_name, "path_fold_map": self.path_fold_map, "auto_name": self.auto_name, "path_fold_auto": self.path_fold_auto, "testingmap_name": self.testingmap_name, "path_fold_testingmap": self.path_fold_testingmap}

            with open(path_to_path_config, "wb") as f:
                pickle.dump(path_dic, f)


    def end(self):
        '''closes the open COM connections of the pumps'''
        for i in self.pump_list:
            i.close()

    def runall(self):
        """turns on all the pumps"""
        if self.pumping_flag == False:
            for j in self.pump_list:
                j.run()
            self.pumping_flag = True
    
    def stopall(self):
        """stops all the pumps"""
        for i in self.pump_list:
            i.stop()
        self.pumping_flag = False

    def set_units(self, units):
        """sets units of all the pumps"""
        for i in self.pump_list:
            i.units(units)

    def set_diameter(self, diameter):
        """sets diameter of all the pumps"""
        for i in self.pump_list:
            i.diameter(diameter)

    def update_vol(self, pump1rate, pump2rate, pump3rate, pump4rate, time_to_run):
        '''updates the self.volume atributes of the class'''
        self.pump1_volume = self.pump1_volume + pump1rate*(time_to_run/60)
        self.pump2_volume = self.pump2_volume + pump2rate*(time_to_run/60)
        self.pump3_volume = self.pump3_volume + pump3rate*(time_to_run/60)
        self.pump4_volume = self.pump4_volume + pump4rate*(time_to_run/60)

        self.pump1_totvol = self.pump1_totvol + pump1rate*(time_to_run/60)
        self.pump2_totvol = self.pump2_totvol + pump2rate*(time_to_run/60)
        self.pump3_totvol = self.pump3_totvol + pump3rate*(time_to_run/60)
        self.pump4_totvol = self.pump4_totvol + pump4rate*(time_to_run/60)

    def check_volume_to_pump(self, pump1rate, pump2rate, pump3rate, pump4rate, time_to_run):
        '''checks to see if there is enough reactant in the pumps to complete the next set of pumping'''
        future_pump1_vol = self.pump1_volume + pump1rate*(time_to_run/60)
        future_pump2_vol = self.pump2_volume + pump2rate*(time_to_run/60)
        future_pump3_vol = self.pump3_volume + pump3rate*(time_to_run/60)
        future_pump4_vol = self.pump4_volume + pump4rate*(time_to_run/60)
        if (future_pump1_vol < self.pump1_max_vol) and (future_pump2_vol < self.pump2_max_vol) and (future_pump3_vol < self.pump3_max_vol) and (future_pump4_vol < self.pump4_max_vol):
            return True
        else:
            return False
    
    def reset_volume(self):
        '''allows for updating of the volumes inside the syringes'''
        new_pump1_vol = float(input("pump 1 new volume:"))
        new_pump2_vol = float(input("pump 2 new volume:"))
        new_pump3_vol = float(input("pump 3 new volume:"))
        new_pump4_vol = float(input("pump 4 new volume:"))
        self.pump1_volume = 0
        self.pump2_volume = 0
        self.pump3_volume = 0
        self.pump4_volume = 0
        if self.units == "mL/min":
            self.pump1_max_vol = new_pump1_vol
            self.pump2_max_vol = new_pump2_vol
            self.pump3_max_vol = new_pump3_vol
            self.pump4_max_vol = new_pump4_vol
        elif self.units == "μL/min":
            self.pump1_max_vol = new_pump1_vol*1000
            self.pump2_max_vol = new_pump2_vol*1000
            self.pump3_max_vol = new_pump3_vol*1000
            self.pump4_max_vol = new_pump4_vol*1000


    def totvolume_pumped(self, name):
        '''returns the total volume pumped by pump 1, 2, 3, or 4'''
        if name == 1:
            volume = self.pump1_totvol
        elif name == 2:
            volume = self.pump2_totvol
        elif name == 3:
            volume = self.pump3_totvol
        elif name == 4:
            volume = self.pump4_totvol
        return volume
    
    def volume_pumped(self, time_to_run, rate):
        """calculates volume pumped by pump"""
        volume = (time_to_run/60)*rate
        return volume

    def append_vol(self, temp_list, time_to_run, pump1rate, pump2rate, pump3rate, pump4rate):
        """appends a inputed list with the pumped volumes by each pump and the total pumped volumes of each pump"""
        temp_list.append(self.volume_pumped(time_to_run, pump1rate))
        temp_list.append(self.volume_pumped(time_to_run, pump2rate))
        temp_list.append(self.volume_pumped(time_to_run, pump3rate))
        temp_list.append(self.volume_pumped(time_to_run, pump4rate))
        temp_list.append(self.totvolume_pumped(1))
        temp_list.append(self.totvolume_pumped(2)) 
        temp_list.append(self.totvolume_pumped(3))
        temp_list.append(self.totvolume_pumped(4))   


    def take_reading(self, attempt_num): 
        """ Method Summary:
                takes reading of intensity... assumes Ximea CamTool is fullscreen on a 4k display
                takes control of keyboard and mouse to do this --
                -- assumes line profile is displaying on lower section of display
                computer cannot be in use while doing this
                sleep times are there to ensure smooth operation -- 
                -- cannot click things too fast, doesn't work

            Arguments:
                attempt_num (str or int): save file name
        """
        pyautogui.hotkey('ctrl','s')
        time.sleep(0.3) ## needs to be here to allow window animation to finish
        pyautogui.typewrite(str(attempt_num))
        time.sleep(0.1)
        pyautogui.press("enter")
        time.sleep(0.1)
        
        pos2 = 563, 1721          
        pyautogui.moveTo(pos2)
        time.sleep(0.1)
        pyautogui.click()
        time.sleep(0.1)
        pyautogui.typewrite(str(attempt_num))
        time.sleep(0.1)
        pyautogui.press("enter")



    def get_reading(self, path, colour):
        """
        Summary:
            loads intesity line profile
        
        Arguments:
            path (str): path to .txt file to be read
            colour (str): which colour channel should be read from line profile
        """
        crosssec_initial_load = np.loadtxt(path, skiprows = 1)
        if colour == "R":
            crosssec_final_load = crosssec_initial_load[:,1]
        elif colour == "G":
            crosssec_final_load = crosssec_initial_load[:,2]
        elif colour == "B":
            crosssec_final_load = crosssec_initial_load[:,3]
        elif colour == "BW":
            crosssec_bw = (crosssec_initial_load[:,1] + crosssec_initial_load[:,2] + crosssec_initial_load[:,3])/3
            crosssec_final_load = crosssec_bw
        elif colour == "BWIN":
            crosssec_bwin = ((crosssec_initial_load[:,1] + crosssec_initial_load[:,2] + crosssec_initial_load[:,3])/(-3))+256
            crosssec_final_load = crosssec_bwin
        elif colour == "RIN":
            crosssec_Rin = crosssec_initial_load[:,1]*-1 + 255
            crosssec_final_load = crosssec_Rin
        elif colour == "GIN":
            crosssec_Gin = crosssec_initial_load[:,2]*-1 + 255
            crosssec_final_load = crosssec_Gin
        elif colour == "BIN":
            crosssec_Bin = crosssec_initial_load[:,3]*-1 + 255
            crosssec_final_load = crosssec_Bin
        else:
            crosssec_final_load = crosssec_initial_load
        return crosssec_final_load



    def aim_ximea(self, path):
        """
        Summary:
            uses mouse and keyboard to aim ximea CamTool program to folder given by path parameter
        Arguments:
            path (str): path to which Ximea CamTool should be directed towards (so that it saves files there)
        """
        time.sleep(3)
        pos2 = 563, 1721          
        pyautogui.moveTo(pos2)
        pyautogui.click()
        pos3 = 1690, 171          
        pyautogui.moveTo(pos3)
        time.sleep(2)
        pyautogui.click()
        time.sleep(0.1)
        pyautogui.typewrite(str(path))
        time.sleep(3)
        pyautogui.press("enter")
        time.sleep(0.2)
        pos4 = 1338, 1290
        pyautogui.moveTo(pos4)
        time.sleep(0.2)
        pyautogui.click()
        number = random.randrange(0,1000)
        name = "aiming" + str(number)
        pyautogui.typewrite(str(name))
        time.sleep(0.2)
        pyautogui.press("enter")
        wn.Beep(500,450)

    
    def steady_state_time_finder(self, pump1_power = 0.5, pump3_power = 0.5, step = -0.25): ## to be improved by measuring intensity and self determining when intensity does not change anymore
        """ 
        Summary:
            method written to make finding steady state equilibration time finding easier... 
            sets a certain FRR for both sets of pumps and waits for input ... 
            after input, FRR are changed, and timer is started
            after another input, when steady steady is achieved, timer is stopped along with pumps
        
        Optional Arguments:
            pump1_power (float): initial pump1 power from >0 - 1 
            pump3_power (float): initial pump3 power from >0 - 1 
            step (float): by how much pump 1 and pump 3 power should increase after first input
        """
        pump1rate = ((self.overall_flow)*0.5)*pump1_power
        pump2rate = ((self.overall_flow)*0.5) - pump1rate
        pump3rate = ((self.overall_flow)*0.5)*pump3_power
        pump4rate = ((self.overall_flow)*0.5) - pump3rate
        self.pump1.rate(pump1rate)
        self.pump2.rate(pump2rate)
        self.pump3.rate(pump3rate)
        self.pump4.rate(pump4rate)
        self.runall()
        input("ready to start timed trial? \n Press any key to initiate change of FRR")
        tik = time.perf_counter()
        pump1rate = ((self.overall_flow)*0.5)*(pump1_power + step)
        pump2rate = ((self.overall_flow)*0.5) - pump1rate
        pump3rate = ((self.overall_flow)*0.5)*(pump3_power + step)
        pump4rate = ((self.overall_flow)*0.5) - pump3rate
        self.pump1.rate(pump1rate)
        self.pump2.rate(pump2rate)
        self.pump3.rate(pump3rate)
        self.pump4.rate(pump4rate)
        wn.Beep(650,400)
        input("Press enter when steady state has been reached")
        tok = time.perf_counter()
        self.stopall()
        wn.Beep(477,389)
        self.equilibration_time = tok - tik
        print("The measured steady state equilibration time was: " + str(round((tok - tik),5)))
        print("The new equilibration time is therefore " + str(self.equilibration_time))
        



        # pump1_power is a parameter from 0 to 1, determining how much of the overall flow is pump1 i.e. 0 is 0, 1 is only pump1
        # pump power has to be >0, <1
    def pumping(self, pump1_power, pump3_power, initial_wait_flag):
        """ 
        Summary:
            method meant for internal use only, sets appropriate pumping rates
            and starts pumps, as well as checking if there is enough volume in syringes
            waits equilibration_time amout of time before continuing
            also returns some list with pump rates and FRRs
        """
        pump1rate = ((self.overall_flow)*0.5)*pump1_power
        pump2rate = ((self.overall_flow)*0.5) - pump1rate
        pump3rate = ((self.overall_flow)*0.5)*pump3_power
        pump4rate = ((self.overall_flow)*0.5) - pump3rate
        self.pump1.rate(pump1rate)
        self.pump2.rate(pump2rate)
        self.pump3.rate(pump3rate)
        self.pump4.rate(pump4rate)
        temp_list = []
        temp_list.append(self.overall_flow)
        temp_list.append((pump1rate))
        temp_list.append((pump2rate))
        temp_list.append((pump3rate))
        temp_list.append((pump4rate))
        temp_list.append((pump1rate/pump2rate))
        temp_list.append((pump3rate/pump4rate))
        temp_list.append(((pump1rate + pump2rate)/(pump3rate + pump4rate)))

        if self.check_volume_to_pump(pump1rate, pump2rate, pump3rate, pump4rate, self.equilibration_time) == False:
            self.stopall()
            wn.Beep(1500,1000)
            wn.Beep (1350, 1000)
            wn.Beep (1600, 1000)
            input("you need to refil the syringes, press enter to continue")
            self.reset_volume()
            initial_wait_flag = False

        tik = time.perf_counter()
        self.runall()
        time.sleep(self.equilibration_time)
        wn.Beep(500,500)
        wn.Beep(700,300)
        return pump1rate, pump2rate, pump3rate, pump4rate, tik, temp_list, initial_wait_flag







    def map_the_space(self, bounds1, bounds2, n1_samples, n2_samples, reverse1_flag, reverse2_flag):
        """ 
        Summary:
            function to generate a map of the four pump FRR space with linear pump power spacing
            i.e. linear concentrations spacing
            Saves files, doesn't do anything else
            bounds1, bounds2 are a tupel of minimum and maximum pump1_power and pump3_power respectively 
            (which overall can be from >0 to <1) ## giving pump power 0 or 1 does not function
            n1_samples, n2_samples are the number of samples to be taken in
            the pump 1 and pump 3 space respectively
        
        Arguments:
            bounds1 (tupel): minimum and maximum pump1_power (from >0 to 1)
            
            bounds2 (tupel): minimum and maximum pump3_power (from >0 to 1)
            
            n1_samples (int): number of steps to be taken to map the pump 1 space
            
            n2_samples (int): number of steps to be taken to map the pump 3 space
            
            reverse1_flag (boolean): if True, will start with highest values in pump 1 space, 
                                     if False, will start with lowest values
                                     this is a mediocre implementation of this, 
                                     it is better handled in the later methods
            
            reverse2_flag (boolean): if True, will start with highest values in pump 3 space, 
                                     if False, will start with lowest values
                                     this is a mediocre implementation of this, 
                                     it is better handled in the later methods    
        """
        
        step1 = (bounds1[1] - bounds1[0])/(n1_samples-1)
        step2 = (bounds2[1] - bounds2[0])/(n2_samples-1)
        initial_wait_flag = False
        for i in range(n1_samples):
            for j in range(n2_samples): 
                if reverse1_flag == False:
                    pump1_power = bounds1[0] + i*step1
                if reverse1_flag == True:
                    pump1_power = bounds1[1] - i*step1 
                if reverse2_flag == False:
                    pump3_power = bounds2[0] + j*step2
                if reverse2_flag == True:
                    pump3_power = bounds2[1] - j*step2

                pump1rate, pump2rate, pump3rate, pump4rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, pump3_power, initial_wait_flag)
                flow_ratio1 = ((pump1rate)/(pump2rate))
                flow_ratio2 = ((pump3rate)/(pump4rate))

                if initial_wait_flag == False:
                    time.sleep(self.equilibration_time)
                    initial_wait_flag = True
                self.take_reading("FRR1 " + str(round(flow_ratio1, 5)) + " FRR2 " + str(round(flow_ratio2, 5)))
                tok = time.perf_counter()
                self.update_vol(pump1rate, pump2rate, pump3rate, pump4rate, (tok-tik))
                self.append_vol(temp_list, (tok-tik), pump1rate, pump2rate, pump3rate, pump4rate)
                self.data_list.append(temp_list)

                data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
                np.savetxt(data_file, (self.data_list)[1:], header = (str(self.data_list[0])))
                wn.Beep(777,687)
        self.stopall()



    def map_the_space_pump1_list(self, pump1_power_array, bounds2, n2_samples, reverse1_flag, reverse2_flag):
        """
        Summary:
            function to generate a map of the four pump FRR space with linear pump power spacing 
            but pump 1 power is given as an array
            i.e. linear concentrations spacing for pump 3 only
            Saves files, doesn't do anything else
            
        Arguments:
            pump1_power_array (list type): list of pump 1 powers to be used 
            
            bounds2 (tupel): minimum and maximum pump3_power (from >0 to 1)
            
            
            n2_samples (int): number of steps to be taken to map the pump 3 space
            
            reverse1_flag (boolean): if True, will start with pump 1 array from the end i.e. will be flipped
            
            reverse1_flag (boolean): if True, will start with highest values in pump 3 space, if False, will start with lowest values
                                        this is a mediocre implementation of this, it is better handled in the later methods
        """
        step2 = (bounds2[1] - bounds2[0])/(n2_samples-1)
        initial_wait_flag = False
        for i in range(len(pump1_power_array)):
            for j in range(n2_samples): 
                if reverse1_flag == False:
                    pump1_power = pump1_power_array[i]
                if reverse1_flag == True:
                    pump1_power = pump1_power_array[(len(pump1_power_array)-i-1)]
                if reverse2_flag == False:
                    pump3_power = bounds2[0] + j*step2
                if reverse2_flag == True:
                    pump3_power = bounds2[1] - j*step2

                pump1rate, pump2rate, pump3rate, pump4rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, pump3_power, initial_wait_flag)
                flow_ratio1 = ((pump1rate)/(pump2rate))
                flow_ratio2 = ((pump3rate)/(pump4rate))

                if initial_wait_flag == False:
                    time.sleep(self.equilibration_time)
                    initial_wait_flag = True
                self.take_reading("FRR1 " + str(round(flow_ratio1, 5)) + " FRR2 " + str(round(flow_ratio2, 5)))
                tok = time.perf_counter()
                self.update_vol(pump1rate, pump2rate, pump3rate, pump4rate, (tok-tik))
                self.append_vol(temp_list, (tok-tik), pump1rate, pump2rate, pump3rate, pump4rate)
                self.data_list.append(temp_list)

                data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
                np.savetxt(data_file, (self.data_list)[1:], header = (str(self.data_list[0])))
                wn.Beep(777,687)
        self.stopall()

    def map_the_space_logspacing(self, pump1_power_array, bounds2, n2_samples):
        """
            Summary:
                function to generate a map of the four pump FRR space with 
                logarithmic (base 10) pump power spacing but pump 1 power is given as an array
                i.e. logarithmic concentrations spacing for pump 3
                Saves files, doesn't do anything else
                splits the pump 3 space into 2 sections if pump power starts above 0.5 and goes below 0.5 
                and makes to measurements by starting with first value above 0.5 and sweeps up
                and then taking measurments starting from the first value below 0.5 and sweeps down
                this is done to improve performance of syringe pumps
                also, these two "first" measurements have 1.5 the input equilibration_time -- 
                -- done this way as when large pumping rate occurs
                then the pumps need longer to equilibrate
                
            Arguments:
                pump1_power_array (list type): list of pump 1 powers to be used 
                
                bounds2 (tupel): minimum and maximum pump3_power (from -inf to <0)
                
                
                n2_samples (int): number of steps to be taken to map the pump 3 space
        """
        pump3_power_list = np.logspace(bounds2[0], bounds2[1], n2_samples)

        for k in pump3_power_list:
            if k > 0.5:
                first_over05num = np.where(pump3_power_list==k)
                split_measurements_into_2_flag = True
                break
            else:
                split_measurements_into_2_flag = False
        
        if split_measurements_into_2_flag == True:
            series_going_up = pump3_power_list[first_over05num[0][0]:]
            series_going_down = np.flip(pump3_power_list[:first_over05num[0][0]])

            for u in range(2):
                if u == 0:
                    pump3_power_array = series_going_up
                    initial_wait_flag = False
                if u == 1:
                    pump3_power_array = series_going_down
                    initial_wait_flag = False

                for i in range(len(pump1_power_array)):
                    for j in range(len(pump3_power_array)):
                        pump1_power = pump1_power_array[i]
                        pump3_power = pump3_power_array[j]

                        pump1rate, pump2rate, pump3rate, pump4rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, pump3_power, initial_wait_flag)
                        flow_ratio1 = ((pump1rate)/(pump2rate))
                        flow_ratio2 = ((pump3rate)/(pump4rate))

                        if initial_wait_flag == False:
                            time.sleep((self.equilibration_time)/2)
                            initial_wait_flag = True
                        self.take_reading("FRR1 " + str(round(flow_ratio1, 5)) + " FRR2 " + str(round(flow_ratio2, 5)))
                        tok = time.perf_counter()
                        self.update_vol(pump1rate, pump2rate, pump3rate, pump4rate, (tok-tik))
                        self.append_vol(temp_list, (tok-tik), pump1rate, pump2rate, pump3rate, pump4rate)
                        self.data_list.append(temp_list)

                        data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
                        np.savetxt(data_file, (self.data_list)[1:], header = (str(self.data_list[0])))
                        wn.Beep(777,687)
                        

        if split_measurements_into_2_flag == False:
            pump3_power_array = np.flip(pump3_power_list)
            initial_wait_flag = False
            for i in range(len(pump1_power_array)):
                for j in range(len(pump3_power_array)):
                    pump1_power = pump1_power_array[i]
                    pump3_power = pump3_power_array[j]

                    pump1rate, pump2rate, pump3rate, pump4rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, pump3_power, initial_wait_flag)
                    flow_ratio1 = ((pump1rate)/(pump2rate))
                    flow_ratio2 = ((pump3rate)/(pump4rate))

                    if initial_wait_flag == False:
                        time.sleep(self.equilibration_time)
                        initial_wait_flag = True
                    self.take_reading("FRR1 " + str(round(flow_ratio1, 5)) + " FRR2 " + str(round(flow_ratio2, 5)))
                    tok = time.perf_counter()
                    self.update_vol(pump1rate, pump2rate, pump3rate, pump4rate, (tok-tik))
                    self.append_vol(temp_list, (tok-tik), pump1rate, pump2rate, pump3rate, pump4rate)
                    self.data_list.append(temp_list)

                    data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
                    np.savetxt(data_file, (self.data_list)[1:], header = (str(self.data_list[0])))
                    wn.Beep(777,687)

        self.stopall()

        
    def load_the_map(self, colour = "R"):
        """
        Summary:
            loads the map i.e. the FRR data along with intensity measurements
            really this is aimed at making 3D surface plots of collected data
            when both pump 1 and pump 3 dilutions are varied
        
        Optional Parameters:
            colour (str): selects which colour channel to use for intensity measurements ... 
            use "R" for BW camera

        Return:
            returns data formatted for 3D plot of mapped space with FRR of pump 1 and 2, 
            FRR of pump 3 and 4 data, and the intesity data for all those points
            ratio1_data, ratio2_data, intensity_array
        """
        data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
        list_of_intsity = []
        list_of_int_std = []

        for flow_ratio1 in np.loadtxt(data_file, skiprows = 1)[:,5]:
            ratio2_intensity_temp_list = []
            ratio2_std_temp_list = []
            for flow_ratio2 in np.loadtxt(data_file, skiprows = 1)[:,6]:
                flow_ratio1 = round(flow_ratio1, 5)
                flow_ratio2 = round(flow_ratio2, 5)
                data_path_of_map_files = str(self.path_fold_map) + "\\FRR1 " + str(flow_ratio1) + " FRR2 " + str(flow_ratio2) + ".txt"
                raw_crosssec = self.get_reading(data_path_of_map_files, colour)
                average_intensity = np.mean(raw_crosssec)
                int_std = np.std(raw_crosssec)
                ratio2_intensity_temp_list.append(average_intensity)
                ratio2_std_temp_list.append(int_std)
            list_of_intsity.append(ratio2_intensity_temp_list)
            list_of_int_std.append(ratio2_std_temp_list)

        _ratio1_array = np.loadtxt(data_file, skiprows = 1)[:,5]  
        _ratio2_array = np.loadtxt(data_file, skiprows = 1)[:,6]

        ratio1_data, ratio2_data = np.meshgrid(_ratio1_array, _ratio2_array)
        intensity_array = np.array(list_of_intsity)

        return ratio1_data, ratio2_data, intensity_array

    def load_the_map_for_scatter(self):
        """
        Summary:
            loads the map i.e. the FRR data along with intensity measurements
            uses colour attribute of class to select colour channel to use
        Return:
            returns data formatted for 3d scatter plot of mapped space with FRR of pump 1 and 2, 
            FRR of pump 3 and 4 data, and the intesity data for all those points
            _1D_pump1_power, _1D_pump3_power, _1D_ratio1_data, _1D_ratio2_data, _1D_intensity_array
        """
        data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
        list_of_intsity = []
        list_of_int_std = []
        list_of_FRR1 = []
        list_of_FRR2 = []
        list_of_pump1_power = []
        list_of_pump3_power = []

        for flow_ratio1 in np.loadtxt(data_file, skiprows = 1)[:,5]:
            for flow_ratio2 in np.loadtxt(data_file, skiprows = 1)[:,6]:
                flow_ratio1 = round(flow_ratio1, 5)
                flow_ratio2 = round(flow_ratio2, 5)
                data_path_of_map_files = str(self.path_fold_map) + "\\FRR1 " + str(flow_ratio1) + " FRR2 " + str(flow_ratio2) + ".txt"
                raw_crosssec = self.get_reading(data_path_of_map_files, self.colour)
                average_intensity = np.mean(raw_crosssec)
                int_std = np.std(raw_crosssec)
                list_of_intsity.append(average_intensity)
                list_of_int_std.append(int_std)
                list_of_FRR1.append(flow_ratio1)
                list_of_FRR2.append(flow_ratio2)
                pump1_power = round((flow_ratio1/(1+flow_ratio1)), 5)
                pump3_power = round((flow_ratio2/(1+flow_ratio2)), 5)
                list_of_pump1_power.append(pump1_power)
                list_of_pump3_power.append(pump3_power)


        _1D_ratio1_data = np.array(list_of_FRR1)
        _1D_ratio2_data = np.array(list_of_FRR2)
        _1D_intensity_array = np.array(list_of_intsity)
        _1D_pump1_power = np.array(list_of_pump1_power)
        _1D_pump3_power = np.array(list_of_pump3_power)

        return _1D_pump1_power, _1D_pump3_power, _1D_ratio1_data, _1D_ratio2_data, _1D_intensity_array

    def load_the_map_only_1_pump_chaning_FRR(self):
        """
        Summary:
            loads the map i.e. the FRR data along with intensity measurements
            assuming only pump 3 was varied i.e. pump 1 had only one FRR inputed
            uses colour attribute of class to select colour channel to use
        Return:
            returns data formatted for scatter plot of mapped space with FRR of 
            pump 1 and 2, FRR of pump 3 and 4 data, and the intesity data for all those points
            int_std is standard deviation (numpy.std) of intesity line profile
            pump1_power, pump3_power, ratio1_data, ratio2_data, intensity, int_std
        """
        data_file = str(self.path_fold) + "\\" + str(self.map_name) + ".txt"
        list_of_intsity = []
        list_of_int_std = []
        list_of_FRR1 = []
        list_of_FRR2 = []
        list_of_pump1_power = []
        list_of_pump3_power = []

        flow_ratio1 = np.loadtxt(data_file, skiprows = 1)[:,5][0]
        for flow_ratio2 in np.loadtxt(data_file, skiprows = 1)[:,6]:
            flow_ratio1 = round(flow_ratio1, 5)
            flow_ratio2 = round(flow_ratio2, 5)

            data_path_of_map_files = str(self.path_fold_map) + "\\FRR1 " + str(flow_ratio1) + " FRR2 " + str(flow_ratio2) + ".txt"
            raw_crosssec = self.get_reading(data_path_of_map_files, self.colour)
            average_intensity = np.mean(raw_crosssec)
            int_std = np.std(raw_crosssec)
            list_of_intsity.append(average_intensity)
            list_of_int_std.append(int_std)
            list_of_FRR1.append(flow_ratio1)
            list_of_FRR2.append(flow_ratio2)
            pump1_power = round((flow_ratio1/(1+flow_ratio1)), 5)
            pump3_power = round((flow_ratio2/(1+flow_ratio2)), 5)
            list_of_pump1_power.append(pump1_power)
            list_of_pump3_power.append(pump3_power)


        ratio1_data = np.array(list_of_FRR1)
        ratio2_data = np.array(list_of_FRR2)
        intensity = np.array(list_of_intsity)
        int_std = np.array(list_of_int_std)
        pump1_power = np.array(list_of_pump1_power)
        pump3_power = np.array(list_of_pump3_power)

        return pump1_power, pump3_power, ratio1_data, ratio2_data, intensity, int_std

    def internal_minimize_fit_func(self, pump3_power):
        """
        Summary:
            method intended to work in conjungtion with minimize_scalar from  scipy.optimize 
            really initially made for 2 pump control program
            enables varing pump 3 power using a quadratic fitting until the self.target_value is reached in measured intensity
            does not save the iterations
            i.e. at the end, have to call self.auto_fit_data_list attribute to have a print out of what the various FRR tested were
        """
        if self.pumping_flag == False:
            initial_wait_flag = False  # flag used to determine if longer (i.e. first measurement) equilibration time is needed
        self.auto_fit_call += 1
        temp2 = []
        temp2.append(pump3_power)
        pump1_power = self.pump1power_internal
        pump1rate, pump2rate, pump3rate, pump4rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, pump3_power, initial_wait_flag)
        flow_ratio1 = ((pump1rate)/(pump2rate))
        flow_ratio2 = ((pump3rate)/(pump4rate))
        print("Your FRR is: " + str(flow_ratio2))
        print("Your pump3 power is: " + str(pump3rate))

        if initial_wait_flag == False:
            time.sleep(self.equilibration_time)
            initial_wait_flag = True

        self.take_reading("auto fit FRR " + str(self.auto_fit_call))
        tok = time.perf_counter()
        self.update_vol(pump1rate, pump2rate, pump3rate, pump4rate, (tok-tik))

        ### get the reading
        data_path = str(self.path_fold_auto) + "\\auto fit FRR " + str(self.auto_fit_call) + ".txt"
        colour = self.colour
        time.sleep(0.5) ### i really don't think this needs to be here, but it resolved a 'file not found' error, or maybe the error resolved itself, and its unncessary
        mean_intensity = np.mean(self.get_reading(data_path, colour))
        temp2.append(mean_intensity)
        self.auto_fit_data_list.append(temp2)
        dif = abs(mean_intensity-self.target_value)
        wn.Beep(576,534)
        return dif


    def target_finding_function(self, mybounds = (0.001, 0.999), x_atol = (0.02), maxiter = 7):
        """
        Summary:
            Method meant to get the program to find the correct pump power to have a specific readout of the sensor
            Uses the interanally defined target value
            Uses a quadratic fit iterator minimize_scalar from scipy.optimize package
            Does not use any previously defined map, searches blind every time
            Saves the pump power applied and the measured sensor readout
        
        Optional Arguments:
            mybounds (tupel): bounds for possible pump power, need to be >0, <1

            x_atol (float): the absolute tolerance of the searching algorithm in the x - axis
                            i.e. it will search within x_atol (e.g. 0.02) on pump power for the target value
            
            maxiter (int): maximum number of allowed iterations before termination
        """
        opt_dic = {'xatol': x_atol, 'maxiter': maxiter}

        self.pump1power_internal = input("What should the pump 1 power be?")
        wn.Beep(700,2000)
        self.aim_ximea(self.path_fold_auto)

        #this does the actual fitting
        minimize_scalar(self.minimize_fit_internal_func, bounds = mybounds, method='bounded', options = opt_dic)
        
        temp_save_data_list = [["pump 3 power", "sensor reading"]]
        temp_save_data_list.append(self.auto_fit_data_list)
        data_file = str(self.path_fold) + "\\target fitting dataset itr " + str(self.auto_fit_call) + ".txt"
        np.savetxt(data_file, (temp_save_data_list)[1:], header = (str(temp_save_data_list[0])))
        print(str(self.auto_fit_data_list))
        self.auto_fit_data_list = []
        print('Sensor setpoint: '+str(self.target_value))
        print('Optimised sensor reading: '+str(self.auto_fit_data_list[-1]))



    def internal_peak_finding_func(self, pump3_power):
        """
        Summary:
            method intended to work in conjungtion with minimize_scalar from  scipy.optimize 
            really initially made for 2 pump control program
            enables varing pump 3 power using a quadratic fitting until the self.target_value is reached in measured intensity
            does not save the iterations
            i.e. at the end, have to call self.auto_fit_data_list attribute to have a print out of what the various FRR tested were
        """
        if self.pumping_flag == False:
            initial_wait_flag = False  # flag used to determine if longer (i.e. first measurement) equilibration time is needed
        self.auto_fit_call += 1
        temp2 = []
        temp2.append(pump3_power)
        pump1_power = self.pump1power_internal
        pump1rate, pump2rate, pump3rate, pump4rate, tik, temp_list, initial_wait_flag = self.pumping(pump1_power, pump3_power, initial_wait_flag)
        flow_ratio1 = ((pump1rate)/(pump2rate))
        flow_ratio2 = ((pump3rate)/(pump4rate))
        print("Your FRR is: " + str(flow_ratio2))
        print("Your pump3 power is: " + str(pump3rate))

        if initial_wait_flag == False:
            time.sleep(self.equilibration_time)
            initial_wait_flag = True

        self.take_reading("auto fit FRR " + str(self.auto_fit_call))
        tok = time.perf_counter()
        self.update_vol(pump1rate, pump2rate, pump3rate, pump4rate, (tok-tik))

        ### get the reading
        data_path = str(self.path_fold_auto) + "\\auto fit FRR " + str(self.auto_fit_call) + ".txt"
        colour = self.colour
        time.sleep(0.5) ### i really don't think this needs to be here, but it resolved a 'file not found' error, or maybe the error resolved itself, and its unncessary
        mean_intensity = np.mean(self.get_reading(data_path, colour))
        temp2.append(mean_intensity)
        self.auto_fit_data_list.append(temp2)
        dif = -mean_intensity
        wn.Beep(576,534)
        return dif


    def peak_finding_function(self, mybounds = (0.001, 0.999), x_atol = (0.02), maxiter = 7):
        """
        Summary:
            Method meant to get the program to find the correct pump power to have maximum of sensor readout
            Uses the interanally defined target value
            Uses a quadratic fit iterator minimize_scalar from scipy.optimize package
            Does not use any previously defined map, searches blind every time
            Saves the pump power applied and the measured sensor readout
        
        Optional Arguments:
            mybounds (tupel): bounds for possible pump power, need to be >0, <1

            x_atol (float): the absolute tolerance of the searching algorithm in the x - axis
                            i.e. it will search within x_atol (e.g. 0.02) on pump power for the target value
            
            maxiter (int): maximum number of allowed iterations before termination
        """
        opt_dic = {'xatol': x_atol, 'maxiter': maxiter}

        self.pump1power_internal = input("What should the pump 1 power be?")
        wn.Beep(700,2000)
        self.aim_ximea(self.path_fold_auto)

        #this does the actual fitting
        minimize_scalar(self.internal_peak_finding_func, bounds = mybounds, method='bounded', options = opt_dic)
        
        temp_save_data_list = [["pump 3 power", "sensor reading"]]
        temp_save_data_list.append(self.auto_fit_data_list)
        data_file = str(self.path_fold) + "\\target fitting dataset itr " + str(self.auto_fit_call) + ".txt"
        np.savetxt(data_file, (temp_save_data_list)[1:], header = (str(temp_save_data_list[0])))
        print(str(self.auto_fit_data_list))
        self.auto_fit_data_list = []
        print('Sensor setpoint: '+str(self.target_value))
        print('Optimised sensor reading: '+str(self.auto_fit_data_list[-1]))






    # These 4 functions below developed/taken from
    # https://stackoverflow.com/questions/57367352/how-to-fit-a-plane-to-a-3d-dataset-in-python
    # were meant to be used to fit surfaces for pump1 and pump3 varying mapped spaces (2D maps)
    def linear_surface_plane_function(self, X, Y, a1, a2, c):
        Z = a1 * X + a2 * Y + c
        return Z
    
    def quadratic_surface_plane_funtion(self, X, Y, a1, a2, a3, a4, a5, c):
        Z = a1*X + a2*Y + a3*X*Y + a4*X*X + a5*Y*Y + c
        return Z

    def linear_surface_fit(self, X, Y, Z):
        x1, y1, z1 = X.flatten(), Y.flatten(), Z.flatten()
        X_data = np.array([x1, y1]).reshape((-1, 2))
        Y_data = z1
        reg = linear_model.LinearRegression().fit(X_data, Y_data)
        a1, a2 = reg.coef_
        c = reg.intercept_
        return a1, a2, c
    
    def quadratic_surface_fit(self, X, Y, Z):
        x1, y1, z1 = X.flatten(), Y.flatten(), Z.flatten()
        x1y1, x1x1, y1y1 = x1*y1, x1*x1, y1*y1
        X_data = np.array([x1, y1, x1y1, x1x1, y1y1]).T  # X_data shape: n, 5
        Y_data = z1
        reg = linear_model.LinearRegression().fit(X_data, Y_data)
        a1, a2, a3, a4, a5 = reg.coef_
        c = reg.intercept_
        return a1, a2, a3, a4, a5, c




    def plot_map(self, colour = "R"):
        """
        Summary:
            plots a 3D surface plot of current experiment map 
            assumes both pump 1 and pump 3 FRRs were varied
            uses FRR as axis -- probably not the axis you want, 
            pump power would be better, as it directly correlates with conc
        """
        ratio1_data, ratio2_data, intensity_array = self.load_the_map(colour)
        fig = plt.figure()
        ax = plt.axes(projection="3d")
        ax.scatter3D(ratio1_data, ratio2_data, intensity_array, c = intensity_array, cmap='cividis')
        titlestr = "Abs Flow " + str(self.overall_flow) + " " + str(self.units) + " : Measured Intensity vs FRR"
        plt.title(titlestr)
        plt.xlabel("Relative Flow Rate Ratio")
        plt.ylabel("Measured Intensity")
        plt.show()


    
def pump3only_auto_mapping(pump_dic, pump1_max_vol, pump2_max_vol, pump3_max_vol, pump4_max_vol, overall_flow, equilibriation_time, target_value, units, path123, communication_rate, colour, syringe_diameter, syringe_volume, _pumps, pump3_half_stock_conc, n_samples, load_dic_path = 0, initial_bounds = (-3, -0.01)):
    """
    Summary:
        Function which calls on the complex_experiment class to 
        iterate through various maps with pump 3 varying in FRR and keep reducing the given bounds untill 
        interesting feature in the map occupies the entire map
        plots the map with each iteration and requires confirmation of continuation ... 
        ...could be deleted by deleting last few lines of function
        Uses variance to determine which part of map are interesting
        I.e., it fits a cubic spline with bc_type = "clamped"
        (end point derrivative has to be 0 -- flat at beginning and bottom)
        and splits the spline into 10 sections, and calculates the variance for each section
        if variance is less than 9% than the max variance found
        then it determines this section as not relevent and will not include it in the next iteration
        it keeps going like this untill all sections are deemed relevent

    Arguments:
        takes all the same arguments as complex_experiment class in same order followed by:

        pump3_half_stock_conc (float): concentration/2 of solution in pump 3 to make x axis in plots accurate
        n_samples (int): number of points to be used in each map
        
    Optional Arguments:
        load_dic_path (str): = 0, path to path_config pickle file to use as first map to start iterations from
        initial_bounds (tupel): = (-3, -0.01), min max tupel for boundaries for logspace of 
                                               pump 3 power to initial sweep if no path to path_config given
    """
    
    continuation_flag = True
    min_bound_limit_flag = False
    max_bound_limit_flag = False

    bounds = initial_bounds
    pump1power_input = float(input("Pump 1 power? (<0-1<)"))
    pump1_power_list = []
    pump1_power_list.append(pump1power_input)

    iter = 0

    while continuation_flag == True:
        
        if load_dic_path != 0:
            exp3 = complex_experiment(pump_dic, pump1_max_vol, pump2_max_vol,
            pump3_max_vol, pump4_max_vol,
            overall_flow, equilibriation_time, target_value, path123, units , syringe_diameter, syringe_volume,
            _pumps, communication_rate, colour, load_dic_path)
        else:
            exp3 = complex_experiment(pump_dic, pump1_max_vol, pump2_max_vol,
            pump3_max_vol, pump4_max_vol,
            overall_flow, equilibriation_time, target_value, path123, units , syringe_diameter, syringe_volume,
            _pumps, communication_rate, colour)

            exp3.aim_ximea(exp3.path_fold_map)
            
            exp3.map_the_space_logspacing(pump1_power_list, bounds, n_samples)

            pump1_max_vol = pump1_max_vol - exp3.pump1_totvol
            pump2_max_vol = pump2_max_vol - exp3.pump2_totvol
            pump3_max_vol = pump3_max_vol - exp3.pump3_totvol
            pump4_max_vol = pump4_max_vol - exp3.pump4_totvol

        iter += 1

        pump1_power, pump3_power, ratio1_data, ratio2_data, intensity, int_std = exp3.load_the_map_only_1_pump_chaning_FRR()

        exp3.end()

        pump3_power, intensity = zip(*sorted(zip(pump3_power, intensity)))
        pump3_power = np.array(pump3_power) 
        intensity = np.array(intensity) 

        cs = CubicSpline(((pump3_power)), (intensity), bc_type = "clamped")
        xvals = np.logspace(np.log10(pump3_power[0]),np.log10(pump3_power[-1]),100)
        yvals = cs(xvals)


        box_size = 10
        box_number = 100/box_size
        color_dic = {"0":"red", "1":"blue", "2":"green", "3":"orange", "4":"purple", "5":"cyan", "6":"magenta", "7":"red", "8":"blue", "9":"green"}
        box_index = 0
        variance_list = []

        for o in range(int(box_number)):
            box_index += box_size
            xvals_box = xvals[(box_index-box_size):box_index]
            yvals_box = yvals[(box_index-box_size):box_index]
            variance_list.append(np.var(yvals_box))

        variance_norm = np.array(variance_list)/max(variance_list)
        for j in range(len(variance_norm)):
            if variance_norm[j] > 0.09:
                min_bound = j - 1
                break
        for j in range(len(variance_norm)):
            if (np.flip(variance_norm))[j] > 0.09:
                max_bound = len(variance_norm) - j + 1
                break

        min_bound_limit_flag = False
        if min_bound == -1:
            min_bound_limit_flag = True
            min_bound = 0
        max_bound_limit_flag = False
        if max_bound == 11:
            max_bound_limit_flag = True
            max_bound == 10

        if max_bound_limit_flag == True:
            xvals_plot = (xvals[(min_bound*box_size):(max_bound*box_size - 1)])*pump3_half_stock_conc
            yvals_plot = yvals[(min_bound*box_size):(max_bound*box_size - 1)]
            new_max_pump_value = xvals[-1]
        else:
            xvals_plot = (xvals[(min_bound*box_size):(max_bound*box_size)])*pump3_half_stock_conc
            yvals_plot = yvals[(min_bound*box_size):(max_bound*box_size)]
            new_max_pump_value = xvals[(max_bound*box_size)]

        xvals_conc = xvals*pump3_half_stock_conc
        new_min_pump_value = xvals[(min_bound*box_size)]
        new_min_input = np.log10(new_min_pump_value)
        new_max_input = np.log10(new_max_pump_value)
        bounds = (new_min_input, new_max_input)

        pump3_power_new = np.logspace(new_min_input, new_max_input, n_samples)
        arbitrary_xs = []
        for j in range(n_samples):
            arbitrary_xs.append((max(intensity)/2))
        pump3_conc = pump3_power*pump3_half_stock_conc
        pump3_conc_new = pump3_power_new*pump3_half_stock_conc

        fig = plt.figure( figsize= (10,5))
        ax = fig.add_subplot()
        plt.plot(pump3_conc, intensity, marker = "s", label = "current pass")
        plt.plot(pump3_conc_new, arbitrary_xs, marker = "s", label = "proposed pass")
        plt.vlines(pump3_conc_new[0], 0, max(intensity), "black")
        plt.vlines(pump3_conc_new[-1], 0, max(intensity), "black")
        plt.legend()
        plt.show()

        fig = plt.figure( figsize= (10,5))
        ax = fig.add_subplot()
        plt.plot(pump3_conc, intensity, marker = "s", label = "current pass")
        plt.plot(pump3_conc_new, arbitrary_xs, marker = "s", label = "proposed pass")
        plt.plot(xvals_plot, yvals_plot, marker = "s", label = "selected cubic spline", alpha = 0.4, color = "black")
        plt.plot(xvals_conc, yvals, marker = "s", label = "cubic spline", alpha = 0.15, color = "grey")
        plt.vlines(pump3_conc_new[0], 0, max(intensity), "black")
        plt.vlines(pump3_conc_new[-1], 0, max(intensity), "black")
        ax.set_xscale("log")
        plt.legend()
        plt.show()

        

        ## check if I want to continue at all
        if (min_bound_limit_flag == True) and (max_bound_limit_flag == True):
            print("optimization complete")
            wn.Beep(440, 600)
            wn.Beep(440, 350)
            wn.Beep(494, 750)
            break


        if input("manual continue?") == "":
            pass
        else:
            break